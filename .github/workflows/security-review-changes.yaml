name: Security Review (Changes)

on:
  workflow_dispatch:
    inputs:
      pull_request_number:
        description: "Optional pull request number to review"
        required: false
        default: ""
      agent:
        description: "Optional reviewer agent (claude or codex)."
        required: false
        default: ""
      model:
        description: "Optional reviewer model override."
        required: false
        default: ""
      timeout_secs:
        description: "Optional reviewer timeout in seconds (defaults to 1800)."
        required: false
        default: ""
  # pull_request:
  #   types:
  #     - opened
  #     - synchronize
  #     - reopened
  #     - ready_for_review
  #     - labeled

concurrency:
  group: security-review-changes-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  pr-security-review:
    name: Pull Request Security Review
    runs-on: ubuntu-24.04
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Install Task
        uses: arduino/setup-task@v2
        with:
          version: 3.x
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Resolve comparison commits
        id: revision
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          base_sha="${{ github.event.pull_request.base.sha }}"
          head_sha="${{ github.sha }}"
          pr_number="${{ github.event.pull_request.number }}"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.pull_request_number }}" ]; then
            pr_json=$(gh pr view "${{ github.event.inputs.pull_request_number }}" --json baseRefOid,headRefOid,number)
            base_sha=$(echo "$pr_json" | jq -r '.baseRefOid')
            head_sha=$(echo "$pr_json" | jq -r '.headRefOid')
            pr_number=$(echo "$pr_json" | jq -r '.number')
          fi

          if [ -n "$base_sha" ]; then
            echo "base=$base_sha" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$head_sha" ]; then
            echo "head=$head_sha" >> "$GITHUB_OUTPUT"
          fi
          if [ -n "$pr_number" ] && [ "$pr_number" != "null" ]; then
            echo "pr=$pr_number" >> "$GITHUB_OUTPUT"
          fi

      - name: Collect updated pin targets
        id: pins
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          base_sha="${{ steps.revision.outputs.base }}"
          head_sha="${{ steps.revision.outputs.head }}"

          if [ -z "$base_sha" ] || [ -z "$head_sha" ]; then
            echo "has_targets=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          task ci -- collect-updated-pins \
            --base "$base_sha" \
            --head "$head_sha" \
            --workspace "${{ github.workspace }}" \
            --output-json pins-context.json \
            --summary-md pins-summary.md

          if [ -s pins-context.json ]; then
            echo "has_targets=true" >> "$GITHUB_OUTPUT"
            echo "context=pins-context.json" >> "$GITHUB_OUTPUT"
          else
            echo "has_targets=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Collect new local servers
        id: newservers
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          base_sha="${{ steps.revision.outputs.base }}"
          head_sha="${{ steps.revision.outputs.head }}"

          if [ -z "$base_sha" ] || [ -z "$head_sha" ]; then
            echo "has_targets=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          task ci -- collect-new-servers \
            --base "$base_sha" \
            --head "$head_sha" \
            --workspace "${{ github.workspace }}" \
            --output-json new-servers-context.json \
            --summary-md new-servers-summary.md

          if [ -s new-servers-context.json ]; then
            echo "has_targets=true" >> "$GITHUB_OUTPUT"
            echo "context=new-servers-context.json" >> "$GITHUB_OUTPUT"
          else
            echo "has_targets=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Gather existing security review metadata
        if: steps.pins.outputs.has_targets == 'true' || steps.newservers.outputs.has_targets == 'true'
        id: existing
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          metadata_file="existing-reviews.json"
          pr_number="${{ steps.revision.outputs.pr }}"
          repo="${{ github.repository }}"

          if [ -n "$pr_number" ]; then
            gh api \
              --paginate \
              repos/$repo/issues/$pr_number/comments \
              --jq '[.[] | select(.body | contains("<!-- automated-security-review:")) | {id: .id, metadata: (.body | capture("<!-- automated-security-review:(?<json>{[^>]+}) -->").json | fromjson)}]' \
              > "$metadata_file" || echo '[]' > "$metadata_file"
          else
            echo '[]' > "$metadata_file"
          fi

          if [ ! -s "$metadata_file" ]; then
            echo '[]' > "$metadata_file"
          fi

          echo "file=$metadata_file" >> "$GITHUB_OUTPUT"

      - name: Run security reviewers
        if: steps.pins.outputs.has_targets == 'true' || steps.newservers.outputs.has_targets == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REVIEW_AGENT_INPUT: ${{ github.event.inputs.agent }}
          REVIEW_MODEL_INPUT: ${{ github.event.inputs.model }}
          REVIEW_TIMEOUT_INPUT: ${{ github.event.inputs.timeout_secs }}
        run: |
          set -euo pipefail

          agent="${REVIEW_AGENT_INPUT:-}"
          if [ -z "$agent" ]; then
            agent="claude"
          fi

          model="${REVIEW_MODEL_INPUT:-}"

          timeout_secs="${REVIEW_TIMEOUT_INPUT:-1800}"

          pr_number="${{ steps.revision.outputs.pr }}"
          repo="${{ github.repository }}"
          metadata_file="${{ steps.existing.outputs.file }}"
          if [ -z "$metadata_file" ] || [ ! -f "$metadata_file" ]; then
            metadata_file="existing-reviews.json"
            echo '[]' > "$metadata_file"
          fi

          mkdir -p review-output

          results_tmp="review-output/review-results.ndjson"
          : > "$results_tmp"
          if [ -s "$metadata_file" ]; then
            jq -c '.[] | {target: .metadata.target, mode: .metadata.mode, base: (.metadata.base // ""), head: (.metadata.head // ""), labels: (.metadata.labels // []), comment_id: (.id|tostring)}' "$metadata_file" >> "$results_tmp"
          fi

          github_repo_regex='^https://github.com/([^/]+)/([^/]+?)(\.git)?$'

          review_target() {
            local mode="$1"
            local server="$2"
            local project="$3"
            local base_commit="$4"
            local head_commit="$5"
            local comment_id=""

            if [ -z "$project" ] || [ "$project" = "null" ]; then
              echo "Skipping $server: missing project URL." >&2
              return
            fi
            if [ "$mode" = "differential" ]; then
              if [ -z "$base_commit" ] || [ "$base_commit" = "null" ] || [ -z "$head_commit" ] || [ "$head_commit" = "null" ]; then
                echo "Skipping $server: missing commit information." >&2
                return
              fi
            else
              if [ -z "$head_commit" ] || [ "$head_commit" = "null" ]; then
                echo "Skipping $server: missing head commit." >&2
                return
              fi
              base_commit=""
            fi

            local exact_id
            exact_id=$(jq -r --arg mode "$mode" --arg target "$server" --arg base "$base_commit" --arg head "$head_commit" '
              map(select(.metadata.mode == $mode and .metadata.target == $target and (.metadata.base // "") == $base and (.metadata.head // "") == $head))
              | first
              | (.id|tostring // "")
            ' "$metadata_file")

            if [ -n "$exact_id" ]; then
              echo "Skipping $server ($mode): already reviewed for this commit." >&2
              return
            fi

            local existing_comment_id
            existing_comment_id=$(jq -r --arg mode "$mode" --arg target "$server" '
              map(select(.metadata.mode == $mode and .metadata.target == $target))
              | first
              | (.id|tostring // "")
            ' "$metadata_file")

            local report_suffix
            if [ "$mode" = "differential" ]; then
              report_suffix="diff"
            else
              report_suffix="full"
            fi

            local report_path="review-output/${server}-${report_suffix}.md"
            local labels_path="review-output/${server}-${report_suffix}-labels.txt"

            cmd=(task security-reviewer -- \
              --agent "$agent" \
              --repo "$project" \
              --head "$head_commit" \
              --target-label "$server" \
              --output "$report_path" \
              --labels-output "$labels_path" \
              --timeout "$timeout_secs")
            if [ "$mode" = "differential" ]; then
              cmd+=(--base "$base_commit")
            fi
            if [ -n "$model" ]; then
              cmd+=(--model "$model")
            fi

            "${cmd[@]}"

            local labels_json
            if [ -s "$labels_path" ]; then
              labels_json=$(jq -Rs 'split("\n") | map(select(length > 0))' "$labels_path")
            else
              labels_json='[]'
            fi

            local repo_slug=""
            if [[ "$project" =~ $github_repo_regex ]]; then
              repo_slug="${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
            fi

            local link_line
            if [ -n "$repo_slug" ]; then
              if [ "$mode" = "differential" ]; then
                link_line="- Diff: [view changes](https://github.com/${repo_slug}/compare/${base_commit}...${head_commit})"
              else
                link_line="- Snapshot: [view tree](https://github.com/${repo_slug}/tree/${head_commit})"
              fi
            else
              if [ "$mode" = "differential" ]; then
                link_line="- Diff: unavailable (non-GitHub repository)."
              else
                link_line="- Snapshot: unavailable (non-GitHub repository)."
              fi
            fi

            local mode_label
            if [ "$mode" = "differential" ]; then
              mode_label="Differential"
            else
              mode_label="Full"
            fi

            local labels_summary
            labels_summary=$(echo "$labels_json" | jq -r 'if length == 0 then "- Labels: none." else "- Labels: " + (join(", ")) end')

            local metadata_json
            metadata_json=$(jq -n --arg target "$server" --arg mode "$mode" --arg base "$base_commit" --arg head "$head_commit" --argjson labels "$labels_json" '{target:$target,mode:$mode,base:$base,head:$head,labels:$labels}')

            local comment_body="review-output/${server}-${report_suffix}-comment.md"
            {
              echo "⚠️ **Automated security review (beta).** This system may make mistakes and is intended only to aid human reviewers."
              echo ""
              echo "- Target: \\`$server\\`"
              echo "- Review mode: $mode_label"
              echo "$link_line"
              echo "$labels_summary"
              echo ""
              echo "---"
              echo ""
              cat "$report_path"
              echo ""
              echo "<!-- automated-security-review:${metadata_json} -->"
            } > "$comment_body"

            if [ -z "$pr_number" ]; then
              echo "No pull request number available; skipping comment publication for $server." >&2
            else
              body_json=$(jq -Rs '.' "$comment_body")
              if [ -n "$existing_comment_id" ]; then
                printf '{"body":%s}\n' "$body_json" | gh api \
                  repos/$repo/issues/comments/$existing_comment_id \
                  --method PATCH \
                  --header "Content-Type: application/json" \
                  --input - >/dev/null
                comment_id="$existing_comment_id"
              else
                comment_response=$(printf '{"body":%s}\n' "$body_json" | gh api \
                  repos/$repo/issues/$pr_number/comments \
                  --method POST \
                  --header "Content-Type: application/json" \
                  --input -)
                comment_id=$(echo "$comment_response" | jq -r '.id | tostring')
              fi
            fi

            jq -n \
              --arg target "$server" \
              --arg mode "$mode" \
              --arg base "$base_commit" \
              --arg head "$head_commit" \
              --argjson labels "$labels_json" \
              --arg comment_id "$comment_id" \
              '{target:$target,mode:$mode,base:$base,head:$head,labels:$labels,comment_id:$comment_id}' \
              >> "$results_tmp"
          }

          if [ "${{ steps.pins.outputs.has_targets }}" = "true" ]; then
            while read -r target; do
              server=$(echo "$target" | jq -r '.server')
              project=$(echo "$target" | jq -r '.project')
              base_commit=$(echo "$target" | jq -r '.old_commit')
              head_commit=$(echo "$target" | jq -r '.new_commit')
              review_target "differential" "$server" "$project" "$base_commit" "$head_commit"
            done < <(jq -c '.[]' "${{ steps.pins.outputs.context }}")
          fi

          if [ "${{ steps.newservers.outputs.has_targets }}" = "true" ]; then
            while read -r target; do
              server=$(echo "$target" | jq -r '.server')
              project=$(echo "$target" | jq -r '.project')
              head_commit=$(echo "$target" | jq -r '.commit')
              review_target "full" "$server" "$project" "" "$head_commit"
            done < <(jq -c '.[]' "${{ steps.newservers.outputs.context }}")
          fi

          if [ -s "$results_tmp" ]; then
            jq -s 'reduce .[] as $item ({}; .[$item.mode + "|" + $item.target] = $item) | [.[]]' "$results_tmp" > "review-output/review-results.json"
            jq -r '.[] | .labels[]?' "review-output/review-results.json" | sort -u > "review-output/labels.txt" || true
            if [ ! -s "review-output/labels.txt" ]; then
              rm -f "review-output/labels.txt"
            fi
          else
            echo '[]' > "review-output/review-results.json"
          fi

      - name: Apply security labels
        if: steps.pins.outputs.has_targets == 'true' || steps.newservers.outputs.has_targets == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          labels_file="${{ github.workspace }}/review-output/labels.txt"
          pr_number="${{ github.event.pull_request.number }}"
          repo="${{ github.repository }}"
          standard_labels=(security-blocked security-risk:critical security-risk:high security-risk:medium security-risk:low security-risk:info)

          if [ -z "$pr_number" ]; then
            echo "No pull request number available; skipping label application." >&2
            exit 0
          fi

          for label in "${standard_labels[@]}"; do
            gh pr edit "$pr_number" --repo "$repo" --remove-label "$label" || true
          done

          if [ ! -f "$labels_file" ] || ! grep -qEv '^\s*$' "$labels_file"; then
            echo "Labels file absent or empty; no labels applied." >&2
            exit 0
          fi

          mapfile -t labels < <(grep -Ev '^\s*$' "$labels_file" | sort -u)

          blocked=false
          highest=""
          for label in "${labels[@]}"; do
            if [ "$label" = "security-blocked" ]; then
              blocked=true
            fi
          done

          for severity in critical high medium low info; do
            candidate="security-risk:${severity}"
            for label in "${labels[@]}"; do
              if [ "$label" = "$candidate" ]; then
                highest="$candidate"
                break 2
              fi
            done
          done

          final_labels=()
          if [ "$blocked" = true ]; then
            final_labels+=("security-blocked")
          fi
          if [ -n "$highest" ]; then
            final_labels+=("$highest")
          fi

          if [ "${#final_labels[@]}" -eq 0 ]; then
            echo "No recognized labels to apply." >&2
            exit 0
          fi

          for label in "${final_labels[@]}"; do
            gh pr edit "$pr_number" --repo "$repo" --add-label "$label" || echo "Warning: unable to apply label $label" >&2
          done
